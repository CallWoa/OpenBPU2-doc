## 发射准备
指令在前端完成译码后，将被前端送入容量为 8 的指令缓冲区队列(下图中 INST QUEUE 8-entries)，后端的 ISU 级每拍最多可以从中取出两条指令。ISU 维护了两个硬件结构:指令环形队列和寄存器使用表。 <br />![image.png](https://github.com/CallWoa/OpenBPU2-doc/blob/master/image/issue1.png?raw=true)<br />指令环形队列中维护了三个值:HeadPtr、TailPtr、Flag。HeadPtr 用于表示下一条发射的指令的编号，TailPtr 用于表示下一条应当提交的指令的编号，Flag 是值为0和1的标记信号。  ![image.png](https://github.com/CallWoa/OpenBPU2-doc/blob/master/image/issue2.png?raw=true)				<br />当 ISU 级出现指令发射时，HeadPtr 会对应加一(仅发射一条)或加二(发射两条)，并将对应的编号和当前的 Flag 值标记在发射出去的指令上。当 HeadPtr 的值增长到队列长度时，HeadPtr 将会归 0 后重新开始增长，Flag 标记则对自身 取反。在这样的算法下，如果要判断两条指令的先后顺序，其逻辑如下:若 Flag 值相同，则编号小的先发射;若 Flag 值不同，则编号大的先发射。指令队列的 长度大于执行级和写回级能容纳的最大指令数，保证每条指令唯一地与一个指令编号对应。 				<br />寄存器使用表有 32 个表项，每个表项分别对应了一个通用寄存器。每当一条指令发射时，寄存器使用表会在该指令要写入的寄存器所对应的表项中记录下该指令的编号，并将该表项的占用标记置为 1。当一条指令提交时，若它的编 号与它要写入的寄存器对应的表项所记录的编号一致，则将该表项的占用标记清零。 <br />![image.png](https://github.com/CallWoa/OpenBPU2-doc/blob/master/image/issue3.png?raw=true)				<br />当一条指令进入 ISU 时，ISU 会根据其译码信息包含的需要的寄存器的地址查询寄存器使用表，若对应表项的占用标记为 0，则从寄存器中直接读出数据; 若对应表项的占用标记为 1，则查看前递端口，若存在寄存器地址一致且指令编号和寄存器使用表中记录的指令编号一致的前递信号，则使用该前递数据。如果以上两种条件均不满足，则该指令将被阻塞在 ISU 内部。如果所需的寄存器数据均被满足，则该指令将被标记上编号和 Flag 的值，送至 ISU 的发送端口上等 待总线的发送成功信号。在收到发射成功的信号后，指令环形队列的 HeadPtr 会根据发射指令数增长或者归 0，Flag 根据 HeadPtr 的情况作对应调整，寄存器使 用表根据将指令要写入的寄存器所对应的表项的有效位置 1，并使用该指令的编号更新表项所记录的指令编号。 			
> 一些需要注意的特殊情况: 				
> 1. ISU 内部可以容纳最多两条指令，因此第二条指令还要检查与第一条指 令的 RAW 数据冲突情况，若存在冲突，则第二条指令将被阻塞，直到第一条指令离开 ISU 级。 				
> 2. 为了确保精确异常，任何 CSR 相关的指令都将被阻塞，直到后端的所有指令都已提交(指令队列中的 HeadPtr=TailPtr) 
> 3. fence 类指令与 CSR 类指令一样，只有当后端所有指令均提交时才可以发射。 

## 指令发射
指令的发射是通过一段组合逻辑控制的，由后端母模块维护。后端母模块在 ISU 的发射端口出现发射请求后，会根据其记录的运算器编号查看 EXU 级对应的指令接收端口，若 EXU 的对应端口允许接收指令(运算器当前闲置或在下一拍将由于指令提交而闲置)，则后端母模块会将 ISU 发射端口的指令信息写入EXU 的指令接收端口(此处用寄存器实现，将在下一拍生效)，并向发射端口发送发射成功的信号。 		<br />后端母模块最多可以处理两条指令的发射，在发射两条指令的时候，第二条指令需要考虑运算器资源强占的问题:即运算器可以接收该指令，但是第一条指令同样需要发送到该运算器中，此时第二条指令将不允许被发射。
